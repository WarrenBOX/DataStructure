数据结构

一、 栈结构 Stack FILO
1. 数据结构:先进后出

2. 例子: 子弹弹夹
        入栈：123
        出栈：321
3. 特点： 入口和出口在集合单侧


二、 队列结构 queue FIFO
1. 数据结构：先进先出
2. 特点： 入口和出口在集合的两侧

三、 数组 Array 查询快，增删慢
1. 数据结构：
    * 地址连续，可以通过数组首地址找到数据，通过索引可以快速查找某个元素
    * 增删慢： 数组的长度是固定的，我们想要增删需要创建新数组，并且复制原数组数据

2. 步骤：new int[] {1,2,3};
    1）删除某个索引的元素
    2）创建新数组,长度是原数组长度-1   *** 增删慢的原因
    3) 把原数组其他元素复制到新数组中
    4）****   在新数组的地址赋值给变量arr  **** important   -> arr不会指向原来地址 -> 失去索引， 垃圾回收
    5）源数组会在内存中被销毁（垃圾回收）


四、 链表的结构 List 查询慢，增删快
1. 数据结构: 链表中地址不是连续的，每次都必须从头开始查询  -》
        节点Node： 每一个元素 -》 由三部分组成
            *  自己的地址 ** reference : list1 @0x11
            *   数据
            *   下一个节点的地址
2. 增删快： 链表结构，增删元素，对链表整体结构没有影响，所以增删快

3. 类别:
    * 单向链表: 链表中只有一条链子，不能保证元素的顺序 （存储元素和取出元素的顺序可能不一致）
    * 双向链表: 在链表中有两条链子，有一条链子是专门记录元素的顺序的 （）


五、 红黑树： 特点趋近于平衡树，查询速度非常的快，查询叶子节点最大次数和最小次数不能超过2倍
    1. 约束：
        * 节点可以是红色或者黑色的
        * 根节点是黑色的
        * 叶子节点（空结点）是黑色的
        * 每个红色的节点的子节点都是黑色的
        * 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

* binary tree： 每个结点不超过2的有序树
* 排序树/查找树: 在二叉树的基础上，元素是有大小排序的
                左子树小，右子树大
* 平衡树： 左孩子和右孩子相等
* 不平衡树：左孩子 ！= 右孩子

----------------------------------------------------------------------------------------------
Collection<E>   集合， 数据的容器  -》 E 为泛型通配符，表示element

一、 List
1. 特点：
    *有序 - 》  存123， 取123
    *有索引
    *允许存储重复数据，
2. 注意事项：
    操作索引的时候，一定防止越界异常


---------------------------------------------------------------------------------------------------------

Hash值：十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）
在Object类有一个方法，可以获取对象的哈希值
int hashcode（）返回对象的哈希值
native表示该方法调用的是本地操作系统的方法

一、HashSet集合存储数据的结构
*jdk1.8之前：哈希表 = 数组 + 链表
*jdk1.8之后： 哈希表 = 数组 + 红黑树(提高查询速度)

哈希表的特点： 查询速度快


二、 Set集合不允许重复元素的原理
*HashSet底层：数组加链表/数组加红黑树
*Set集合在调用add方法时，add方法会调用元素的hashcode方法和equals方法判断元素是否重复


